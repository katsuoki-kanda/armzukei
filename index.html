<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>形と色のポーズゲーム - レイアウト最終調整版</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; background: #000; color: white; font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif; overflow: hidden; position: fixed; width: 100%; height: 100%; }
        canvas { position: absolute; left: 0; top: 0; width: 100vw; height: 100vh; object-fit: contain; background: #000; }
        video { display: none; }
        
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; text-align: center; z-index: 10; }
        .hud-left { position: absolute; top: 5px; left: 15px; font-size: 3.5vw; color: #0f0; text-shadow: 2px 2px 4px #000; font-weight: bold; }
        .hud-right { position: absolute; top: 5px; right: 15px; font-size: 3.5vw; color: #fff; text-shadow: 2px 2px 4px #000; font-weight: bold; }
        #question { position: absolute; top: 5px; width: 100%; font-size: 7vw; color: #ff0; text-shadow: 3px 3px 0px #f00; font-weight: bold; }
        
        /* 下部のスペースを空けたため、メッセージを少し上に配置 */
        #msg { position: absolute; top: 65%; width: 100%; font-size: 4.2vw; color: #0ff; text-shadow: 2px 2px 4px #000; white-space: pre-wrap; }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; text-align: center;
        }
        #startButton {
            padding: 15px 30px; font-size: 18px; font-weight: bold; border-radius: 50px;
            border: none; background: #2ecc71; color: white; cursor: pointer; margin-top: 20px;
        }
    </style>
</head>
<body>

    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-left">Score: <span id="score">0</span></div>
        <div class="hud-right">Time: <span id="timer">60</span></div>
        <div id="question"></div>
        <div id="msg"></div>
    </div>

    <div id="overlay">
        <h1 style="color:#ff0; font-size: 6vw;">図形あてゲーム</h1>
        <p>指示された色と形をタッチしてね！<br>正解したら両手を合わせて次へ</p>
        <button id="startButton">ゲームをはじめる</button>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const questionEl = document.getElementById('question');
        const msgEl = document.getElementById('msg');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('startButton');

        let audioCtx;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(freq, type = 'sine', duration = 0.15) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }

        function speak(text) {
            window.speechSynthesis.cancel();
            const uttr = new SpeechSynthesisUtterance(text);
            uttr.lang = 'ja-JP';
            window.speechSynthesis.speak(uttr);
        }

        const colors = [
            { name: "あか", code: "#ff0000" },
            { name: "あお", code: "#0088ff" },
            { name: "きいろ", code: "#ffff00" }
        ];
        const shapes = ["しかく", "さんかく", "まる"];
        let comboList = [];
        colors.forEach(c => { shapes.forEach(s => { comboList.push({ label: c.name + s, colorName: c.name, colorCode: c.code, shapeType: s }); }); });

        let score = 0, timeLeft = 60, gameActive = false;
        let targets = [], currentAnswer = null, isProcessingNext = false;
        let isCooldown = false;
        let canTouch = true; 
        let waitingForClap = false; 
        let circleRadius = 50;

        function updateCanvasSize() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            circleRadius = Math.min(canvasElement.width, canvasElement.height) * 0.08;
        }
        window.addEventListener('resize', updateCanvasSize);
        updateCanvasSize();

        function drawTargetShape(ctx, x, y, size, type, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            if (type === "まる") {
                ctx.arc(x, y, size, 0, Math.PI * 2);
            } else if (type === "しかく") {
                ctx.rect(x - size, y - size, size * 2, size * 2);
            } else if (type === "さんかく") {
                ctx.moveTo(x, y - size);
                ctx.lineTo(x - size, y + size);
                ctx.lineTo(x + size, y + size);
                ctx.closePath();
            }
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function generateTargets() {
            targets = [];
            const shuffled = [...comboList].sort(() => Math.random() - 0.5);
            const W = canvasElement.width;
            const H = canvasElement.height;
            
            // --- レイアウトの調整 ---
            // 左右の余白を5%に削減（より端の方まで配置）
            const marginX = W * 0.05 + circleRadius;
            // 配置を上部22%〜60%に制限（下部40%を空ける）
            const startY = H * 0.22; 
            const endY = H * 0.60;
            
            for (let i = 0; i < 9; i++) {
                let x, y, tooClose;
                let attempts = 0;
                do {
                    tooClose = false;
                    x = Math.random() * (W - marginX * 2) + marginX;
                    y = Math.random() * (endY - startY) + startY;

                    for (let t of targets) {
                        const d = Math.sqrt((x - t.x)**2 + (y - t.y)**2);
                        // 図形同士の最低間隔
                        if (d < circleRadius * 2.5) { tooClose = true; break; }
                    }
                    attempts++;
                } while (tooClose && attempts < 200);
                targets.push({ x, y, data: shuffled[i] });
            }
        }

        function nextRound() {
            waitingForClap = false;
            canTouch = true;
            isProcessingNext = false;
            msgEl.innerText = "";
            currentAnswer = comboList[Math.floor(Math.random() * comboList.length)];
            questionEl.innerText = currentAnswer.label;
            generateTargets();
            speak(currentAnswer.label);
        }

        function startGame() {
            if (gameActive || isCooldown) return;
            score = 0; timeLeft = 60;
            scoreEl.innerText = score;
            gameActive = true;
            nextRound();
            
            const timerInterval = setInterval(() => {
                if (!gameActive) { clearInterval(timerInterval); return; }
                timeLeft--;
                timerEl.innerText = timeLeft;
                if (timeLeft <= 0) endGame();
            }, 1000);
        }

        function endGame() {
            gameActive = false;
            waitingForClap = false;
            questionEl.innerText = "";
            msgEl.innerText = "終了！\nスコア: " + score;
            speak(`${score}点です。終了。`);
            isCooldown = true;
            setTimeout(() => {
                isCooldown = false;
                if (!gameActive) msgEl.innerText = "腕を挙げてスタート";
            }, 3000);
        }

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // ビデオ描画
            canvasCtx.translate(canvasElement.width, 0);
            canvasCtx.scale(-1, 1);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();

            if (results.poseLandmarks) {
                // 左右の手を正しく紐付け (MediaPipeのインデックスを反転に対応させて取得)
                const handLandmarks = [results.poseLandmarks[20], results.poseLandmarks[19]]; 
                const hands = [];

                handLandmarks.forEach((hand) => {
                    if (hand && hand.visibility > 0.5) {
                        const hx = (1 - hand.x) * canvasElement.width; 
                        const hy = hand.y * canvasElement.height;
                        hands.push({x: hx, y: hy});

                        canvasCtx.strokeStyle = waitingForClap ? "#0af" : "yellow";
                        canvasCtx.lineWidth = 5;
                        canvasCtx.beginPath();
                        canvasCtx.arc(hx, hy, 30, 0, Math.PI * 2);
                        canvasCtx.stroke();

                        // 開始判定（上部に手を挙げる）
                        if (hand.y < 0.2 && !isCooldown) startGame();
                    }
                });

                // クラップ音と次への遷移
                if (gameActive && waitingForClap && hands.length === 2) {
                    const dist = Math.sqrt((hands[0].x - hands[1].x)**2 + (hands[0].y - hands[1].y)**2);
                    if (dist < 80) {
                        playSound(440, 'square', 0.1);
                        nextRound();
                    }
                }

                // 図形へのタッチ判定
                if (gameActive && !isProcessingNext && canTouch && !waitingForClap) {
                    hands.forEach(h => {
                        targets.forEach(t => {
                            if (t.data.label === currentAnswer.label) {
                                const dist = Math.sqrt((h.x - t.x)**2 + (h.y - t.y)**2);
                                if (dist < circleRadius + 25) {
                                    isProcessingNext = true;
                                    canTouch = false;
                                    waitingForClap = true;
                                    score++;
                                    scoreEl.innerText = score;
                                    playSound(880, 'sine', 0.15);
                                    msgEl.innerText = "せいかい！\n両手を合わせて次へ";
                                    speak("正解。両手を合わせて。");
                                }
                            }
                        });
                    });
                }

                if (gameActive) {
                    targets.forEach(t => {
                        drawTargetShape(canvasCtx, t.x, t.y, circleRadius, t.data.shapeType, t.data.colorCode);
                    });
                }
            }
        }

        const pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
        pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        pose.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await pose.send({image: videoElement}); },
            width: 1280, height: 720,
            facingMode: 'user'
        });

        startBtn.addEventListener('click', () => {
            initAudio();
            overlay.style.display = 'none';
            msgEl.innerText = "カメラ準備中...";
            camera.start().then(() => {
                msgEl.innerText = "腕を挙げてスタート";
            });
        });
    </script>
</body>
</html>